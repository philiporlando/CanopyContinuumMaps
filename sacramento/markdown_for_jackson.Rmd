---
title: "sacramento_population_density_grid"
author: "Philip Orlando"
date: "April 2, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading dependencies

```{r}
if (!require(pacman)) {
  install.packages("pacman")
  library(pacman)
}

p_load(readr
       #,ggplot2
       ,plyr
       ,dplyr
       ,tidyr
       ,stringr
       ,magrittr
       ,rgeos
       ,rgdal
       ,sp
       ,leaflet
       ,sf
       ,raster
       ,mapview
       ,tidycensus
       ,tidyverse
       ,RPostgres
       ,RColorBrewer
       ,classInt
       ,htmltools
       ,scales
       ,htmlwidgets
)
```


## Creating projection variables

``` {r}
# geography projection
wgs_84 <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "

# Sacramento, CA, UTM 10S, meters
epsg_26911 <- "+proj=utm +zone=10 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"

```


## Storing our census API key

``` {r}
KEY <- scan("census_key.pgpss", what = "")
#census_api_key(KEY, install = TRUE, overwrite = TRUE)
#readRenviron("~/.Renviron")

```

## Reading in census data

``` {r, results="hide", message=FALSE, warning=FALSE}
acs <- get_acs(year = "2016"
               ,geography = "block group" 
               ,variables = "B00001_001E" # unweighted total population
               ,state = "CA"
               ,county = c("Sacramento"
                           ,"El Dorado"
                           ,"Nevada"
                           ,"Placer"
                           ,"Sutter"
                           ,"Yolo"
                           ,"Yuba"
                           #,"Douglas" # Nevada
                           ) # counties taken from wiki sacramento metro area page
               ,key = KEY
               ,output = "wide"
               ,geometry = TRUE
)

```


## Project acs data into meters

``` {r}
acs <- st_transform(acs, epsg_26911)
```


## Read in US urban areas shapefile
``` {r}
urban_areas <- readOGR(dsn = "./data/tigerline/tl_2017_us_uac10.shp")
```

## Extracting only Sacramento, CA polygon

``` {r}
sacra <- subset(urban_areas, str_detect(NAME10, "Sacramento, CA"))
```

## Reprojecting into meters

```{r}
sacra <- spTransform(sacra, CRSobj = CRS(epsg_26911))

```

## Creating our grid topology

First we determine the bounding box of our urban area

``` {r}
bb <- bbox(sacra)
```

Then we specify the size of each grid cell

``` {r}
cs <- c(2000, 2000) # 2km x 2km
```

Determine the cell offset and starting point (lower right corner?)

``` {r}
cc <- bb[, 1] + (cs/2) # cell offset, centering bottom right corner at the halfway point

```

Dynamically calculate the number of cells per direction from this reference point

``` {r}
cd <- ceiling(diff(t(bb))/cs)
```

Convert to a grid topology

``` {r}
grd <- GridTopology(cellcentre.offset = cc, cellsize = cs, cells.dim = cd)
grd
```

Convert to a `SpatialGridDataFrame` for plotting with `leaflet()`

``` {r}
sp_grd <- SpatialGridDataFrame(grd, data = data.frame(id=1:prod(cd)),
                               proj4string = CRS(proj4string(sacra)))
```

Then convert to `SpatialPolygonsDataFrame` for `gIntersection()` with city boundary

``` {r}
grid_poly <- as(sp_grd, "SpatialPolygonsDataFrame")
```

Clipping by the city boundary

``` {r}
grid <- grid_poly[sacra, ]
```

## Areal interpolation of block group population data and our grid cells

First, we're converting from `sp` to `sf` objects

``` {r}
grid <- st_as_sf(grid)
sacra <- st_as_sf(sacra)
```

Then, we need to create an empty dataframe to store the output of our for loops

``` {r}
# create any empty dataframe
output_names <- c("grid_cell_id", "bg_name", "weighted_pop", "bg_pop", "relative_area", "bg_area", "cell_area")
output_df <- data.frame(matrix(ncol = length(output_names), nrow = 0))
colnames(output_df) <- output_names
```

Now we can iterate through each grid cell to get an area-weighted population from each block group.
Figuring out how to vectorize this would be a huge help moving forward!

``` {r, results='hide', warning=FALSE, messages=FALSE}
# for each cell in our grid
for(i in 1:nrow(grid)) {
  
  # capture each row of our grid dataframe
  cell <- grid[i, ]
  
  # store cell id variable
  cell_id <- cell$id
  
  # determine the grid cell area (4 km^2)
  cell_area <- as.numeric(st_area(cell$geometry))
  
  # iterate through each block group
  for(j in 1:nrow(acs)) {
    
    # capture each row of our block group data
    bg <- acs[j, ]
    
    # determine if a block group intersects with a grid cell
    overlap <- st_intersects(cell$geometry, bg$geometry)[[1]]
    
    # calculate relative population per grid cell per block group if they intersect
    if(!is_empty(overlap)) {
      
      # block group area
      bg_area <- as.numeric(st_area(bg$geometry))
      
      # relative area within the grid cell
      relative_area <- as.numeric(st_area(st_intersection(cell$geometry, bg$geometry)))
      
      # block group population
      bg_pop <- bg$B00001_001E
      
      # area-weighted population for that grid cell
      weighted_pop <- bg_pop*(relative_area/bg_area)
      
      # block group name
      bg_name <- bg$NAME
      
      # print each row to console (verbose output)
      print(paste(cell_id, bg_name, weighted_pop, bg_pop))
      
      # store each row in our output dataframe
      output_df = rbind(output_df
                        ,data.frame(grid_cell_id = cell_id
                                    ,bg_name = bg_name
                                    ,weighted_pop = weighted_pop
                                    ,bg_pop = bg_pop
                                    ,relative_area = relative_area
                                    ,bg_area = bg_area
                                    ,cell_area = cell_area
                        )
                        ,stringsAsFactors=FALSE)
      
    } 
    
    
  }
  
}
```

Sum each grid cell's weighted population for each intersecting block group.


``` {r}
grid_pop <- output_df %>% 
  group_by(grid_cell_id) %>%
  summarise(population = sum(weighted_pop))
```

Append the population data back to the original grid data, joining by cell id.

``` {r}
grid <- left_join(grid, grid_pop, by = c("id" = "grid_cell_id"))
```

## Creating a webmap with our new dataframe

We need to convert back from `sf` to `sp` objects.


``` {r}
grid_sp <- as(grid, "Spatial")

```


And then reproject back to WGS84

``` {r}
projection(grid_sp)
grid_sp <- spTransform(grid_sp, CRSobj = CRS(wgs_84))

```

We also need to create a color code to plot our population density variable

``` {r}
levels <- 10
plotclr <- brewer.pal(levels, "RdYlGn")
class <- classIntervals(grid_sp@data$population, n = levels, style = "quantile")
colcode <- findColours(class, rev(plotclr))

```

We can create a hover-on label for each grid cell too. 

``` {r}
labels <- sprintf(
  "<strong>ID: %s</strong><br/> Population Density: %s/2km<sup>2</sup>"
  ,grid_sp@data$id, comma(round(grid_sp@data$population, 0))
) %>% 
  lapply(HTML)

```

## Leaflet time!

``` {r}
labels <- sprintf(
  "<strong>ID: %s</strong><br/> Population Density: %s/2km<sup>2</sup>"
  ,grid_sp@data$id
  ,comma(round(grid_sp@data$population, 0))
) %>% 
  lapply(HTML)

leaflet() %>%
  
  addTiles('http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png') %>%
  
  addPolygons(data = grid_sp
              ,color = "black"
              ,fillColor = colcode
              ,fillOpacity = 0.20
              ,weight = 0.5
              #,popup = pop1
              # interaction
              ,highlight = highlightOptions(
                weight = 5
                ,color = "#666" # U+1F608
                ,dashArray = ""
                ,fillOpacity = 0.7
                ,bringToFront = TRUE
              )
              ,label = labels
              ,labelOptions = labelOptions(
                style = list("font-weight" = "normal"
                             ,padding = "3px 8px"
                )
                ,textsize = "15px"
                ,direction = "auto"
              )
  ) %>%
  
addScaleBar()
```
